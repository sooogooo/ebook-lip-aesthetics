<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç®€åŒ–3Dè§£å‰–æ¨¡å‹</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            background: linear-gradient(135deg, #2c3e50, #3498db);
            color: white;
            overflow: hidden;
        }

        #canvas {
            width: 100vw;
            height: 100vh;
            display: block;
            cursor: grab;
        }

        #canvas:active {
            cursor: grabbing;
        }

        .controls {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 8px;
        }

        .info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
        }

        button {
            background: #3498db;
            color: white;
            border: none;
            padding: 8px 12px;
            margin: 2px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        button:hover {
            background: #2980b9;
        }

        button:active {
            background: #1f5f99;
        }

        .error {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(231, 76, 60, 0.9);
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            z-index: 1000;
        }

        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1000;
            text-align: center;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(255,255,255,0.3);
            border-top: 4px solid white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="loading" class="loading">
        <div class="spinner"></div>
        <div>æ­£åœ¨åŠ è½½3Dè§£å‰–æ¨¡å‹...</div>
    </div>

    <canvas id="canvas"></canvas>

    <div class="controls">
        <h3>ğŸ§¬ 3Då”‡éƒ¨è§£å‰–</h3>
        <button onclick="resetView()">é‡ç½®è§†è§’</button>
        <button onclick="toggleLayer('skin')">çš®è‚¤å±‚</button>
        <button onclick="toggleLayer('muscle')">è‚Œè‚‰å±‚</button>
        <button onclick="toggleLayer('vessels')">è¡€ç®¡</button>
        <button onclick="toggleWireframe()">çº¿æ¡†æ¨¡å¼</button>
    </div>

    <div class="info">
        <div>ğŸ–±ï¸ æ‹–æ‹½æ—‹è½¬ | ğŸ” æ»šè½®ç¼©æ”¾</div>
        <div id="fps">FPS: --</div>
        <div id="status">çŠ¶æ€: åˆå§‹åŒ–ä¸­</div>
    </div>

    <script>
        // åŸºç¡€WebGLä¸Šä¸‹æ–‡å’Œå˜é‡
        let canvas, gl, program;
        let rotation = { x: 0, y: 0 };
        let scale = 1;
        let isDragging = false;
        let lastMouse = { x: 0, y: 0 };
        let layers = { skin: true, muscle: true, vessels: true };
        let wireframe = false;
        let frameCount = 0;
        let fpsStart = Date.now();

        // åŸºç¡€å‡ ä½•ä½“æ•°æ®
        const lipGeometry = {
            vertices: [
                // å”‡éƒ¨åŸºç¡€å½¢çŠ¶ (ä¸Šå”‡)
                -0.5, 0.2, 0.0,   0.0, 0.3, 0.1,   0.5, 0.2, 0.0,
                -0.4, 0.1, 0.05,  0.0, 0.15, 0.1,  0.4, 0.1, 0.05,
                // ä¸‹å”‡
                -0.4, -0.1, 0.05, 0.0, -0.2, 0.1,  0.4, -0.1, 0.05,
                -0.3, -0.25, 0.0, 0.0, -0.3, 0.05, 0.3, -0.25, 0.0,
                // å†…éƒ¨ç»“æ„ç‚¹
                -0.2, 0.0, 0.15,  0.0, 0.0, 0.2,   0.2, 0.0, 0.15
            ],
            colors: [
                // çš®è‚¤é¢œè‰² (æ·¡ç²‰è‰²)
                1.0, 0.8, 0.7,   1.0, 0.75, 0.7,  1.0, 0.8, 0.7,
                1.0, 0.8, 0.75,  1.0, 0.75, 0.7,  1.0, 0.8, 0.75,
                // æ›´æ·±çš„ç²‰è‰²
                0.9, 0.7, 0.6,   0.95, 0.65, 0.6, 0.9, 0.7, 0.6,
                0.9, 0.65, 0.6,  0.95, 0.65, 0.6, 0.9, 0.65, 0.6,
                // å†…éƒ¨è‚Œè‚‰é¢œè‰² (çº¢è‰²ç³»)
                0.8, 0.4, 0.3,   0.8, 0.4, 0.3,   0.8, 0.4, 0.3
            ],
            indices: [
                // ä¸Šå”‡é¢
                0, 1, 3,   1, 4, 3,   1, 2, 4,   2, 5, 4,
                // ä¸‹å”‡é¢
                6, 7, 9,   7, 10, 9,  7, 8, 10,  8, 11, 10,
                // è¿æ¥é¢
                3, 4, 6,   4, 7, 6,   4, 5, 7,   5, 8, 7,
                // å†…éƒ¨ç»“æ„
                12, 13, 14
            ]
        };

        // ç€è‰²å™¨ä»£ç 
        const vertexShaderSource = `
            attribute vec3 a_position;
            attribute vec3 a_color;
            uniform mat4 u_matrix;
            varying vec3 v_color;
            void main() {
                gl_Position = u_matrix * vec4(a_position, 1.0);
                v_color = a_color;
            }
        `;

        const fragmentShaderSource = `
            precision mediump float;
            varying vec3 v_color;
            uniform float u_alpha;
            void main() {
                gl_FragColor = vec4(v_color, u_alpha);
            }
        `;

        function init() {
            canvas = document.getElementById('canvas');

            try {
                gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                if (!gl) {
                    throw new Error('WebGL not supported');
                }

                updateStatus('WebGLåˆå§‹åŒ–æˆåŠŸ');
                setupShaders();
                setupGeometry();
                setupEventListeners();
                resizeCanvas();

                document.getElementById('loading').style.display = 'none';
                updateStatus('3Dæ¨¡å‹åŠ è½½å®Œæˆ');

                render();

            } catch (error) {
                showError('åˆå§‹åŒ–å¤±è´¥: ' + error.message);
            }
        }

        function setupShaders() {
            const vertexShader = createShader(gl.VERTEX_SHADER, vertexShaderSource);
            const fragmentShader = createShader(gl.FRAGMENT_SHADER, fragmentShaderSource);

            program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);

            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                throw new Error('Shader program failed to link');
            }

            gl.useProgram(program);
        }

        function createShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                throw new Error('Shader compilation error: ' + gl.getShaderInfoLog(shader));
            }

            return shader;
        }

        function setupGeometry() {
            // é¡¶ç‚¹ç¼“å†²åŒº
            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(lipGeometry.vertices), gl.STATIC_DRAW);

            const a_position = gl.getAttribLocation(program, 'a_position');
            gl.enableVertexAttribArray(a_position);
            gl.vertexAttribPointer(a_position, 3, gl.FLOAT, false, 0, 0);

            // é¢œè‰²ç¼“å†²åŒº
            const colorBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(lipGeometry.colors), gl.STATIC_DRAW);

            const a_color = gl.getAttribLocation(program, 'a_color');
            gl.enableVertexAttribArray(a_color);
            gl.vertexAttribPointer(a_color, 3, gl.FLOAT, false, 0, 0);

            // ç´¢å¼•ç¼“å†²åŒº
            const indexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(lipGeometry.indices), gl.STATIC_DRAW);

            // è®¾ç½®WebGLçŠ¶æ€
            gl.enable(gl.DEPTH_TEST);
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
            gl.clearColor(0.1, 0.1, 0.2, 1.0);
        }

        function createMatrix() {
            // ç®€åŒ–çš„çŸ©é˜µè®¡ç®—
            const matrix = new Float32Array(16);

            // é€è§†æŠ•å½±çŸ©é˜µ
            const aspect = canvas.width / canvas.height;
            const fov = Math.PI / 4;
            const near = 0.1;
            const far = 100.0;

            const f = Math.tan(Math.PI * 0.5 - 0.5 * fov);
            const rangeInv = 1.0 / (near - far);

            matrix[0] = f / aspect;
            matrix[1] = 0;
            matrix[2] = 0;
            matrix[3] = 0;

            matrix[4] = 0;
            matrix[5] = f;
            matrix[6] = 0;
            matrix[7] = 0;

            matrix[8] = 0;
            matrix[9] = 0;
            matrix[10] = (near + far) * rangeInv;
            matrix[11] = -1;

            matrix[12] = 0;
            matrix[13] = 0;
            matrix[14] = near * far * rangeInv * 2;
            matrix[15] = 0;

            // åº”ç”¨æ—‹è½¬å’Œç¼©æ”¾
            const cosX = Math.cos(rotation.x);
            const sinX = Math.sin(rotation.x);
            const cosY = Math.cos(rotation.y);
            const sinY = Math.sin(rotation.y);

            // ç®€åŒ–æ—‹è½¬ - åªæ˜¾ç¤ºåŸºæœ¬æ•ˆæœ
            matrix[0] *= cosY * scale;
            matrix[5] *= cosX * scale;
            matrix[14] -= 3; // å‘åç§»åŠ¨

            return matrix;
        }

        function render() {
            frameCount++;
            if (frameCount % 60 === 0) {
                const now = Date.now();
                const fps = Math.round(60000 / (now - fpsStart));
                document.getElementById('fps').textContent = `FPS: ${fps}`;
                fpsStart = now;
            }

            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            const matrix = createMatrix();
            const u_matrix = gl.getUniformLocation(program, 'u_matrix');
            gl.uniformMatrix4fv(u_matrix, false, matrix);

            const u_alpha = gl.getUniformLocation(program, 'u_alpha');
            gl.uniform1f(u_alpha, 0.8);

            if (wireframe) {
                for (let i = 0; i < lipGeometry.indices.length; i += 3) {
                    gl.drawElements(gl.LINE_LOOP, 3, gl.UNSIGNED_SHORT, i * 2);
                }
            } else {
                gl.drawElements(gl.TRIANGLES, lipGeometry.indices.length, gl.UNSIGNED_SHORT, 0);
            }

            requestAnimationFrame(render);
        }

        function setupEventListeners() {
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('wheel', handleWheel);

            window.addEventListener('resize', resizeCanvas);
        }

        function handleMouseDown(e) {
            isDragging = true;
            lastMouse = { x: e.clientX, y: e.clientY };
        }

        function handleMouseMove(e) {
            if (!isDragging) return;

            const deltaX = e.clientX - lastMouse.x;
            const deltaY = e.clientY - lastMouse.y;

            rotation.y += deltaX * 0.01;
            rotation.x += deltaY * 0.01;

            lastMouse = { x: e.clientX, y: e.clientY };
        }

        function handleMouseUp(e) {
            isDragging = false;
        }

        function handleWheel(e) {
            e.preventDefault();
            scale += e.deltaY * -0.001;
            scale = Math.max(0.1, Math.min(3, scale));
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }

        // æ§åˆ¶å‡½æ•°
        function resetView() {
            rotation = { x: 0, y: 0 };
            scale = 1;
            updateStatus('è§†è§’å·²é‡ç½®');
        }

        function toggleLayer(layer) {
            layers[layer] = !layers[layer];
            updateStatus(`${layer}å±‚: ${layers[layer] ? 'æ˜¾ç¤º' : 'éšè—'}`);
        }

        function toggleWireframe() {
            wireframe = !wireframe;
            updateStatus(`çº¿æ¡†æ¨¡å¼: ${wireframe ? 'å¼€å¯' : 'å…³é—­'}`);
        }

        function updateStatus(message) {
            document.getElementById('status').textContent = `çŠ¶æ€: ${message}`;
        }

        function showError(message) {
            document.getElementById('loading').style.display = 'none';
            document.body.innerHTML += `<div class="error"><h3>âŒ é”™è¯¯</h3><p>${message}</p></div>`;
        }

        // å¯åŠ¨åº”ç”¨
        window.onload = init;
    </script>
</body>
</html>