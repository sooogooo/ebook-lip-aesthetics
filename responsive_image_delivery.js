/**\n * Advanced Responsive Image Delivery System\n * Supports WebP, AVIF, progressive loading, and intelligent format selection\n * Optimized for mobile performance and battery efficiency\n */\n\nclass ResponsiveImageDelivery {\n    constructor(options = {}) {\n        this.options = {\n            formats: ['avif', 'webp', 'jpg'],\n            qualities: [90, 70, 50],\n            sizes: {\n                mobile: { width: 480, suffix: '_mobile' },\n                tablet: { width: 768, suffix: '_tablet' },\n                desktop: { width: 1200, suffix: '_desktop' },\n                retina: { width: 2400, suffix: '_retina' }\n            },\n            enableProgressiveLoading: true,\n            enableLazyLoading: true,\n            enablePreloading: true,\n            enableAdaptiveQuality: true,\n            preloadCount: 3,\n            intersectionThreshold: 0.1,\n            lowPowerMode: false,\n            cacheDuration: 7 * 24 * 60 * 60 * 1000, // 7 days\n            ...options\n        };\n\n        this.cache = new Map();\n        this.observer = null;\n        this.preloadQueue = [];\n        this.loadingImages = new Set();\n        this.supportedFormats = new Set();\n        this.networkInfo = null;\n        this.batteryInfo = null;\n        this.performanceMetrics = {\n            loadTimes: [],\n            failureRate: 0,\n            averageSize: 0,\n            bandwidthEstimate: 0\n        };\n\n        this.init();\n    }\n\n    async init() {\n        try {\n            // Detect supported image formats\n            await this.detectSupportedFormats();\n\n            // Initialize network monitoring\n            await this.initializeNetworkMonitoring();\n\n            // Initialize battery monitoring\n            await this.initializeBatteryMonitoring();\n\n            // Setup intersection observer for lazy loading\n            this.setupIntersectionObserver();\n\n            // Setup performance monitoring\n            this.setupPerformanceMonitoring();\n\n            console.log('[ImageDelivery] System initialized with formats:', Array.from(this.supportedFormats));\n        } catch (error) {\n            console.error('[ImageDelivery] Initialization failed:', error);\n        }\n    }\n\n    async detectSupportedFormats() {\n        const formatTests = {\n            avif: 'data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgABogQEAwgMg8f8D///8WfhwB8+ErK42A=',\n            webp: 'data:image/webp;base64,UklGRjoAAABXRUJQVlA4IC4AAACyAgCdASoCAAIALmk0mk0iIiIiIgBoSygABc6WWgAA/veff/0PP8bA//LwYAAA',\n            jpg: 'data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD/2wBDAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/2wBDAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/wAARCAABAAEDASIAAhEBAxEB/8QAFQABAQAAAAAAAAAAAAAAAAAAAAv/xAAUEAEAAAAAAAAAAAAAAAAAAAAA/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAX/xAAUEQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIRAxEAPwA/8A'\n        };\n\n        for (const [format, testData] of Object.entries(formatTests)) {\n            try {\n                const isSupported = await this.testImageFormat(testData);\n                if (isSupported) {\n                    this.supportedFormats.add(format);\n                }\n            } catch (error) {\n                console.warn(`[ImageDelivery] Format ${format} test failed:`, error);\n            }\n        }\n\n        // Fallback to JPEG if no modern formats are supported\n        if (this.supportedFormats.size === 0) {\n            this.supportedFormats.add('jpg');\n        }\n    }\n\n    testImageFormat(testData) {\n        return new Promise((resolve) => {\n            const img = new Image();\n            img.onload = () => resolve(img.width === 2 && img.height === 2);\n            img.onerror = () => resolve(false);\n            img.src = testData;\n        });\n    }\n\n    async initializeNetworkMonitoring() {\n        if ('connection' in navigator) {\n            this.networkInfo = {\n                effectiveType: navigator.connection.effectiveType || '4g',\n                downlink: navigator.connection.downlink || 10,\n                rtt: navigator.connection.rtt || 100,\n                saveData: navigator.connection.saveData || false\n            };\n\n            navigator.connection.addEventListener('change', () => {\n                this.updateNetworkInfo();\n            });\n        } else {\n            this.networkInfo = {\n                effectiveType: '4g',\n                downlink: 10,\n                rtt: 100,\n                saveData: false\n            };\n        }\n    }\n\n    async initializeBatteryMonitoring() {\n        if ('getBattery' in navigator) {\n            try {\n                const battery = await navigator.getBattery();\n                this.batteryInfo = {\n                    level: battery.level,\n                    charging: battery.charging\n                };\n\n                battery.addEventListener('levelchange', () => {\n                    this.batteryInfo.level = battery.level;\n                    this.adjustForBattery();\n                });\n\n                battery.addEventListener('chargingchange', () => {\n                    this.batteryInfo.charging = battery.charging;\n                    this.adjustForBattery();\n                });\n            } catch (error) {\n                console.warn('[ImageDelivery] Battery API not available:', error);\n            }\n        }\n    }\n\n    updateNetworkInfo() {\n        if ('connection' in navigator) {\n            this.networkInfo.effectiveType = navigator.connection.effectiveType;\n            this.networkInfo.downlink = navigator.connection.downlink;\n            this.networkInfo.rtt = navigator.connection.rtt;\n            this.networkInfo.saveData = navigator.connection.saveData;\n\n            // Adjust quality based on network conditions\n            this.adjustQualityForNetwork();\n        }\n    }\n\n    adjustForBattery() {\n        if (this.batteryInfo) {\n            const shouldOptimize = this.batteryInfo.level < 0.2 && !this.batteryInfo.charging;\n            this.options.lowPowerMode = shouldOptimize;\n\n            if (shouldOptimize) {\n                // Reduce quality and disable some features in low power mode\n                this.options.enablePreloading = false;\n                this.options.qualities = [70, 50, 30];\n            } else {\n                // Restore normal operation\n                this.options.enablePreloading = true;\n                this.options.qualities = [90, 70, 50];\n            }\n        }\n    }\n\n    adjustQualityForNetwork() {\n        if (!this.networkInfo) return;\n\n        const { effectiveType, downlink, saveData } = this.networkInfo;\n\n        if (saveData || effectiveType === 'slow-2g' || effectiveType === '2g') {\n            this.options.qualities = [50, 30, 20];\n            this.options.enablePreloading = false;\n        } else if (effectiveType === '3g' || downlink < 1.5) {\n            this.options.qualities = [70, 50, 30];\n            this.options.enablePreloading = true;\n            this.options.preloadCount = 1;\n        } else {\n            this.options.qualities = [90, 70, 50];\n            this.options.enablePreloading = true;\n            this.options.preloadCount = 3;\n        }\n    }\n\n    setupIntersectionObserver() {\n        if ('IntersectionObserver' in window) {\n            this.observer = new IntersectionObserver(\n                (entries) => this.handleIntersection(entries),\n                {\n                    rootMargin: '50px',\n                    threshold: this.options.intersectionThreshold\n                }\n            );\n        }\n    }\n\n    setupPerformanceMonitoring() {\n        // Monitor performance metrics to optimize delivery\n        setInterval(() => {\n            this.analyzePerformanceMetrics();\n        }, 10000); // Every 10 seconds\n    }\n\n    /**\n     * Main image delivery methods\n     */\n    async loadImage(src, container, options = {}) {\n        const loadOptions = { ...this.options, ...options };\n        const imageId = this.generateImageId(src);\n\n        try {\n            // Check cache first\n            if (this.cache.has(imageId)) {\n                return this.loadFromCache(imageId, container);\n            }\n\n            // Start loading process\n            const startTime = performance.now();\n            this.loadingImages.add(imageId);\n\n            // Generate responsive image URLs\n            const imageSet = this.generateResponsiveImageSet(src, loadOptions);\n\n            // Select optimal image based on device and conditions\n            const optimalImage = this.selectOptimalImage(imageSet);\n\n            // Load with progressive enhancement\n            const result = await this.loadWithProgressiveEnhancement(\n                optimalImage,\n                container,\n                loadOptions\n            );\n\n            // Cache successful result\n            this.cache.set(imageId, {\n                result,\n                timestamp: Date.now(),\n                size: result.size || 0\n            });\n\n            // Record performance metrics\n            this.recordLoadMetrics(imageId, performance.now() - startTime, true);\n\n            return result;\n\n        } catch (error) {\n            console.error(`[ImageDelivery] Failed to load image ${src}:`, error);\n            this.recordLoadMetrics(imageId, 0, false);\n            return this.loadFallbackImage(container);\n        } finally {\n            this.loadingImages.delete(imageId);\n        }\n    }\n\n    generateResponsiveImageSet(src, options) {\n        const imageSet = {};\n        const baseName = src.replace(/\\.[^/.]+$/, ''); // Remove extension\n\n        for (const [sizeName, sizeConfig] of Object.entries(options.sizes)) {\n            imageSet[sizeName] = {};\n\n            for (const format of this.supportedFormats) {\n                if (options.formats.includes(format)) {\n                    for (const quality of options.qualities) {\n                        const url = this.buildImageUrl(baseName, sizeConfig, format, quality);\n                        imageSet[sizeName][format] = imageSet[sizeName][format] || [];\n                        imageSet[sizeName][format].push({\n                            url,\n                            quality,\n                            estimatedSize: this.estimateImageSize(sizeConfig.width, format, quality)\n                        });\n                    }\n                }\n            }\n        }\n\n        return imageSet;\n    }\n\n    buildImageUrl(baseName, sizeConfig, format, quality) {\n        return `${baseName}${sizeConfig.suffix}_q${quality}.${format}`;\n    }\n\n    selectOptimalImage(imageSet) {\n        const devicePixelRatio = window.devicePixelRatio || 1;\n        const screenWidth = window.innerWidth * devicePixelRatio;\n        const viewportSize = this.getViewportSize();\n\n        // Select appropriate size based on viewport\n        let selectedSize = 'mobile';\n        if (screenWidth >= 1200) {\n            selectedSize = devicePixelRatio > 1 ? 'retina' : 'desktop';\n        } else if (screenWidth >= 768) {\n            selectedSize = 'tablet';\n        }\n\n        const sizeImages = imageSet[selectedSize] || imageSet.mobile;\n        if (!sizeImages) {\n            throw new Error('No images available for selected size');\n        }\n\n        // Select optimal format based on support and network conditions\n        const format = this.selectOptimalFormat(sizeImages);\n        const formatImages = sizeImages[format];\n\n        if (!formatImages || formatImages.length === 0) {\n            throw new Error(`No images available for format ${format}`);\n        }\n\n        // Select optimal quality based on network and battery conditions\n        const quality = this.selectOptimalQuality(formatImages);\n\n        return formatImages.find(img => img.quality === quality) || formatImages[0];\n    }\n\n    selectOptimalFormat(sizeImages) {\n        // Prefer AVIF > WebP > JPEG based on support and network conditions\n        const preferredOrder = ['avif', 'webp', 'jpg'];\n\n        // In low power mode or poor network, prefer WebP over AVIF for faster decode\n        if (this.options.lowPowerMode || this.isSlowNetwork()) {\n            preferredOrder.splice(0, 1); // Remove AVIF\n        }\n\n        for (const format of preferredOrder) {\n            if (sizeImages[format] && this.supportedFormats.has(format)) {\n                return format;\n            }\n        }\n\n        // Fallback to first available format\n        return Object.keys(sizeImages)[0];\n    }\n\n    selectOptimalQuality(formatImages) {\n        let targetQuality = 90;\n\n        // Adjust quality based on network conditions\n        if (this.networkInfo) {\n            switch (this.networkInfo.effectiveType) {\n                case 'slow-2g':\n                case '2g':\n                    targetQuality = 30;\n                    break;\n                case '3g':\n                    targetQuality = 50;\n                    break;\n                case '4g':\n                default:\n                    targetQuality = this.options.lowPowerMode ? 70 : 90;\n                    break;\n            }\n\n            // Further reduce quality if save-data is enabled\n            if (this.networkInfo.saveData) {\n                targetQuality = Math.min(targetQuality, 50);\n            }\n        }\n\n        // Find closest available quality\n        return formatImages.reduce((closest, current) => {\n            return Math.abs(current.quality - targetQuality) < Math.abs(closest.quality - targetQuality)\n                ? current\n                : closest;\n        }).quality;\n    }\n\n    async loadWithProgressiveEnhancement(imageData, container, options) {\n        const img = new Image();\n        img.loading = 'lazy';\n        img.decoding = 'async';\n\n        // Add responsive attributes\n        this.addResponsiveAttributes(img, imageData, options);\n\n        // Progressive loading with placeholder\n        if (options.enableProgressiveLoading) {\n            await this.loadWithPlaceholder(img, imageData, container);\n        }\n\n        return new Promise((resolve, reject) => {\n            const loadStartTime = performance.now();\n\n            img.onload = () => {\n                const loadTime = performance.now() - loadStartTime;\n                console.log(`[ImageDelivery] Image loaded in ${loadTime.toFixed(2)}ms`);\n\n                // Apply smooth transition\n                this.applyLoadTransition(img, container);\n\n                resolve({\n                    element: img,\n                    loadTime,\n                    size: imageData.estimatedSize,\n                    format: this.getImageFormat(imageData.url),\n                    quality: imageData.quality\n                });\n            };\n\n            img.onerror = () => {\n                console.error(`[ImageDelivery] Failed to load image: ${imageData.url}`);\n                reject(new Error(`Failed to load image: ${imageData.url}`));\n            };\n\n            // Set source last to trigger loading\n            img.src = imageData.url;\n        });\n    }\n\n    async loadWithPlaceholder(img, imageData, container) {\n        // Create low-quality placeholder\n        const placeholder = await this.createPlaceholder(imageData);\n        if (placeholder) {\n            container.appendChild(placeholder);\n\n            // Remove placeholder when main image loads\n            img.addEventListener('load', () => {\n                setTimeout(() => {\n                    if (placeholder.parentNode) {\n                        placeholder.parentNode.removeChild(placeholder);\n                    }\n                }, 300);\n            });\n        }\n    }\n\n    async createPlaceholder(imageData) {\n        // Generate SVG placeholder or use blurred low-quality image\n        const placeholder = document.createElement('div');\n        placeholder.className = 'image-placeholder';\n        placeholder.style.cssText = `\n            position: absolute;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 100%;\n            background: linear-gradient(45deg, #f0f0f0, #e0e0e0);\n            opacity: 0.8;\n            transition: opacity 0.3s ease;\n        `;\n\n        return placeholder;\n    }\n\n    applyLoadTransition(img, container) {\n        img.style.opacity = '0';\n        img.style.transition = 'opacity 0.3s ease';\n        container.appendChild(img);\n\n        // Trigger fade-in\n        requestAnimationFrame(() => {\n            img.style.opacity = '1';\n        });\n    }\n\n    /**\n     * Lazy loading and preloading\n     */\n    observeElement(element, src, options = {}) {\n        if (this.observer) {\n            element.dataset.src = src;\n            element.dataset.options = JSON.stringify(options);\n            this.observer.observe(element);\n        } else {\n            // Fallback for browsers without IntersectionObserver\n            this.loadImage(src, element, options);\n        }\n    }\n\n    handleIntersection(entries) {\n        entries.forEach(entry => {\n            if (entry.isIntersecting) {\n                const element = entry.target;\n                const src = element.dataset.src;\n                const options = JSON.parse(element.dataset.options || '{}');\n\n                if (src) {\n                    this.loadImage(src, element, options);\n                    this.observer.unobserve(element);\n\n                    // Preload next images if enabled\n                    if (this.options.enablePreloading) {\n                        this.preloadNearbyImages(element);\n                    }\n                }\n            }\n        });\n    }\n\n    preloadNearbyImages(currentElement) {\n        // Find nearby images to preload\n        const nearbyElements = this.findNearbyElements(currentElement);\n        const preloadPromises = [];\n\n        for (let i = 0; i < Math.min(nearbyElements.length, this.options.preloadCount); i++) {\n            const element = nearbyElements[i];\n            const src = element.dataset.src;\n\n            if (src && !this.loadingImages.has(this.generateImageId(src))) {\n                preloadPromises.push(this.preloadImage(src));\n            }\n        }\n\n        return Promise.allSettled(preloadPromises);\n    }\n\n    async preloadImage(src) {\n        const imageId = this.generateImageId(src);\n\n        // Check if already cached\n        if (this.cache.has(imageId)) {\n            return;\n        }\n\n        // Add to preload queue\n        this.preloadQueue.push(src);\n\n        // Process queue with throttling\n        this.processPreloadQueue();\n    }\n\n    /**\n     * Utility methods\n     */\n    generateImageId(src) {\n        return btoa(src).replace(/[^a-zA-Z0-9]/g, '');\n    }\n\n    getViewportSize() {\n        return {\n            width: window.innerWidth,\n            height: window.innerHeight\n        };\n    }\n\n    isSlowNetwork() {\n        if (!this.networkInfo) return false;\n        return ['slow-2g', '2g', '3g'].includes(this.networkInfo.effectiveType) ||\n               this.networkInfo.downlink < 1.5;\n    }\n\n    estimateImageSize(width, format, quality) {\n        // Rough estimation based on format and quality\n        const baseSize = width * width * 0.75; // Assume 4:3 aspect ratio\n        const formatMultiplier = {\n            'avif': 0.3,\n            'webp': 0.4,\n            'jpg': 1.0\n        };\n        const qualityMultiplier = quality / 100;\n\n        return baseSize * formatMultiplier[format] * qualityMultiplier;\n    }\n\n    getImageFormat(url) {\n        const extension = url.split('.').pop().toLowerCase();\n        return extension;\n    }\n\n    addResponsiveAttributes(img, imageData, options) {\n        img.setAttribute('data-format', this.getImageFormat(imageData.url));\n        img.setAttribute('data-quality', imageData.quality);\n        img.setAttribute('data-estimated-size', imageData.estimatedSize);\n    }\n\n    /**\n     * Performance tracking\n     */\n    recordLoadMetrics(imageId, loadTime, success) {\n        if (success) {\n            this.performanceMetrics.loadTimes.push(loadTime);\n            \n            // Keep only recent measurements\n            if (this.performanceMetrics.loadTimes.length > 100) {\n                this.performanceMetrics.loadTimes.shift();\n            }\n        } else {\n            this.performanceMetrics.failureRate += 0.01;\n        }\n\n        // Decay failure rate over time\n        this.performanceMetrics.failureRate *= 0.99;\n    }\n\n    analyzePerformanceMetrics() {\n        const loadTimes = this.performanceMetrics.loadTimes;\n        if (loadTimes.length === 0) return;\n\n        const averageLoadTime = loadTimes.reduce((a, b) => a + b, 0) / loadTimes.length;\n        const p95LoadTime = loadTimes.sort((a, b) => a - b)[Math.floor(loadTimes.length * 0.95)];\n\n        console.log(`[ImageDelivery] Performance metrics:`, {\n            averageLoadTime: averageLoadTime.toFixed(2),\n            p95LoadTime: p95LoadTime.toFixed(2),\n            failureRate: (this.performanceMetrics.failureRate * 100).toFixed(2) + '%',\n            cacheSize: this.cache.size\n        });\n\n        // Auto-adjust based on performance\n        if (averageLoadTime > 2000) { // 2 seconds\n            this.autoOptimizeForPerformance();\n        }\n    }\n\n    autoOptimizeForPerformance() {\n        console.log('[ImageDelivery] Auto-optimizing for performance');\n\n        // Reduce quality targets\n        this.options.qualities = this.options.qualities.map(q => Math.max(q - 10, 20));\n\n        // Reduce preload count\n        this.options.preloadCount = Math.max(this.options.preloadCount - 1, 1);\n\n        // Clear old cache entries\n        this.cleanCache();\n    }\n\n    cleanCache() {\n        const now = Date.now();\n        const expiredEntries = [];\n\n        for (const [key, value] of this.cache.entries()) {\n            if (now - value.timestamp > this.options.cacheDuration) {\n                expiredEntries.push(key);\n            }\n        }\n\n        expiredEntries.forEach(key => this.cache.delete(key));\n        console.log(`[ImageDelivery] Cleaned ${expiredEntries.length} expired cache entries`);\n    }\n\n    /**\n     * Public API methods\n     */\n    enableLowPowerMode() {\n        this.options.lowPowerMode = true;\n        this.adjustForBattery();\n    }\n\n    disableLowPowerMode() {\n        this.options.lowPowerMode = false;\n        this.adjustForBattery();\n    }\n\n    getPerformanceMetrics() {\n        return { ...this.performanceMetrics };\n    }\n\n    getCacheInfo() {\n        return {\n            size: this.cache.size,\n            entries: Array.from(this.cache.keys())\n        };\n    }\n\n    destroy() {\n        if (this.observer) {\n            this.observer.disconnect();\n        }\n        this.cache.clear();\n        this.loadingImages.clear();\n        this.preloadQueue.length = 0;\n    }\n}\n\n// Global instance\nwindow.ResponsiveImageDelivery = ResponsiveImageDelivery;\n\n// Auto-initialize if not in module environment\nif (typeof module === 'undefined') {\n    window.imageDelivery = new ResponsiveImageDelivery();\n    console.log('[ImageDelivery] Global instance created');\n}\n\nexport default ResponsiveImageDelivery;"