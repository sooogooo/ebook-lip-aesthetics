const fs = require('fs').promises;
const path = require('path');
const { minify } = require('html-minifier-terser');
const critical = require('critical');
const cheerio = require('cheerio');

// HTML optimization configuration
const htmlOptimizationConfig = {
  minifier: {
    collapseWhitespace: true,
    removeComments: true,
    removeRedundantAttributes: true,
    removeScriptTypeAttributes: true,
    removeStyleLinkTypeAttributes: true,
    removeEmptyAttributes: true,
    useShortDoctype: true,
    minifyCSS: true,
    minifyJS: true,
    minifyURLs: true,
    removeAttributeQuotes: true,
    sortAttributes: true,
    sortClassName: true,
    processConditionalComments: true,
    removeEmptyElements: false,
    keepClosingSlash: false,
    quoteCharacter: '"',
    preventAttributesEscaping: true,
    processScripts: ['application/ld+json'],
    collapseBooleanAttributes: true,
    collapseInlineTagWhitespace: true,
    decodeEntities: true,
    includeAutoGeneratedTags: false,
    maxLineLength: 1000,
    noNewlinesBeforeTagClose: true,
    preserveLineBreaks: false,
    removeTagWhitespace: true,
    trimCustomFragments: true
  },
  critical: {
    inline: true,
    width: 1920,
    height: 1080,
    penthouse: {
      timeout: 30000,
      pageLoadSkipTimeout: 10000
    },
    minify: true,
    extract: true
  }
};

async function optimizeHTML(inputPath, outputPath) {
  try {
    let html = await fs.readFile(inputPath, 'utf8');

    // Load HTML with cheerio
    const $ = cheerio.load(html);

    // Inline critical CSS
    const criticalCSS = await extractCriticalCSS($);
    if (criticalCSS) {
      $('head').prepend(`<style>${criticalCSS}</style>`);
    }

    // Optimize resource loading
    optimizeResourceLoading($);

    // Add preload/prefetch hints
    addResourceHints($);

    // Implement lazy loading
    implementLazyLoading($);

    // Add performance monitoring
    addPerformanceMonitoring($);

    // Get modified HTML
    html = $.html();

    // Minify HTML
    const minified = await minify(html, htmlOptimizationConfig.minifier);

    // Write optimized HTML
    await fs.writeFile(outputPath, minified);

    // Calculate compression stats
    const originalSize = Buffer.byteLength(html, 'utf8');
    const minifiedSize = Buffer.byteLength(minified, 'utf8');
    const compressionRatio = ((1 - minifiedSize / originalSize) * 100).toFixed(2);

    return {
      file: path.basename(inputPath),
      originalSize,
      minifiedSize,
      compressionRatio,
      saved: originalSize - minifiedSize
    };
  } catch (error) {
    console.error(`Error optimizing ${inputPath}:`, error);
    throw error;
  }
}

async function extractCriticalCSS($) {
  // Extract inline critical CSS from linked stylesheets
  const criticalRules = [];

  // Critical selectors that should be inlined
  const criticalSelectors = [
    'body', 'html', 'header', 'nav', 'main',
    '.hero', '.container', '.btn-primary',
    '[data-critical]', '.above-fold'
  ];

  // This is a simplified version - in production, use the critical package
  const cssLinks = $('link[rel="stylesheet"]').toArray();

  for (const link of cssLinks) {
    const href = $(link).attr('href');
    if (href && href.includes('.min.css')) {
      // Mark for async loading
      $(link).attr('media', 'print');
      $(link).attr('onload', "this.media='all'");
    }
  }

  return null; // Return extracted critical CSS here
}

function optimizeResourceLoading($) {
  // Convert synchronous scripts to async/defer
  $('script[src]').each((i, script) => {
    const $script = $(script);
    const src = $script.attr('src');

    if (!$script.attr('async') && !$script.attr('defer')) {
      // Use defer for scripts that need to maintain order
      if (src.includes('integration') || src.includes('main')) {
        $script.attr('defer', '');
      } else {
        // Use async for independent scripts
        $script.attr('async', '');
      }
    }
  });

  // Optimize CSS loading
  $('link[rel="stylesheet"]').each((i, link) => {
    const $link = $(link);
    const href = $link.attr('href');

    if (!href.includes('.critical.')) {
      // Load non-critical CSS asynchronously
      $link.attr('media', 'print');
      $link.attr('onload', "this.media='all'; this.onload=null;");

      // Add noscript fallback
      const noscript = `<noscript><link rel="stylesheet" href="${href}"></noscript>`;
      $link.after(noscript);
    }
  });
}

function addResourceHints($) {
  const head = $('head');

  // Add DNS prefetch for external domains
  const externalDomains = [
    'https://fonts.googleapis.com',
    'https://fonts.gstatic.com',
    'https://cdn.jsdelivr.net'
  ];

  externalDomains.forEach(domain => {
    head.append(`<link rel="dns-prefetch" href="${domain}">`);
    head.append(`<link rel="preconnect" href="${domain}" crossorigin>`);
  });

  // Preload critical resources
  const criticalResources = [
    { href: '/unified_styles.min.css', as: 'style' },
    { href: '/integration.min.js', as: 'script' },
    { href: '/fonts/main.woff2', as: 'font', type: 'font/woff2', crossorigin: true }
  ];

  criticalResources.forEach(resource => {
    const attrs = Object.entries(resource)
      .map(([key, value]) => value === true ? key : `${key}="${value}"`)
      .join(' ');
    head.append(`<link rel="preload" ${attrs}>`);
  });

  // Prefetch next likely navigation
  const prefetchPages = [
    '/medical_dashboard.html',
    '/enhanced_3d_anatomy.html'
  ];

  prefetchPages.forEach(page => {
    head.append(`<link rel="prefetch" href="${page}">`);
  });
}

function implementLazyLoading($) {
  // Add lazy loading to images
  $('img').each((i, img) => {
    const $img = $(img);

    if (!$img.attr('loading')) {
      $img.attr('loading', 'lazy');

      // Add intersection observer attributes
      const src = $img.attr('src');
      if (src && !src.startsWith('data:')) {
        $img.attr('data-src', src);
        $img.attr('src', 'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1 1"%3E%3C/svg%3E');
        $img.addClass('lazy-load');
      }
    }
  });

  // Add lazy loading to iframes
  $('iframe').each((i, iframe) => {
    const $iframe = $(iframe);
    if (!$iframe.attr('loading')) {
      $iframe.attr('loading', 'lazy');
    }
  });

  // Add lazy loading script
  const lazyLoadScript = `
    <script>
      (function() {
        const lazyImages = document.querySelectorAll('img.lazy-load');
        const imageObserver = new IntersectionObserver((entries) => {
          entries.forEach(entry => {
            if (entry.isIntersecting) {
              const img = entry.target;
              img.src = img.dataset.src;
              img.classList.remove('lazy-load');
              imageObserver.unobserve(img);
            }
          });
        }, { rootMargin: '50px 0px' });
        lazyImages.forEach(img => imageObserver.observe(img));
      })();
    </script>
  `;

  $('body').append(lazyLoadScript);
}

function addPerformanceMonitoring($) {
  const perfScript = `
    <script>
      // Performance monitoring
      (function() {
        // Core Web Vitals monitoring
        function sendMetric(metric) {
          if (navigator.sendBeacon) {
            const data = JSON.stringify({
              name: metric.name,
              value: metric.value,
              id: metric.id,
              timestamp: Date.now()
            });
            navigator.sendBeacon('/api/metrics', data);
          }
        }

        // Observe LCP
        new PerformanceObserver((list) => {
          for (const entry of list.getEntries()) {
            sendMetric({
              name: 'LCP',
              value: entry.renderTime || entry.loadTime,
              id: entry.id
            });
          }
        }).observe({ type: 'largest-contentful-paint', buffered: true });

        // Observe FID
        new PerformanceObserver((list) => {
          for (const entry of list.getEntries()) {
            sendMetric({
              name: 'FID',
              value: entry.processingStart - entry.startTime,
              id: entry.id
            });
          }
        }).observe({ type: 'first-input', buffered: true });

        // Observe CLS
        let clsValue = 0;
        let clsEntries = [];
        new PerformanceObserver((list) => {
          for (const entry of list.getEntries()) {
            if (!entry.hadRecentInput) {
              const firstSessionEntry = clsEntries[0];
              const lastSessionEntry = clsEntries[clsEntries.length - 1];

              if (entry.startTime - lastSessionEntry.startTime < 1000 &&
                  entry.startTime - firstSessionEntry.startTime < 5000) {
                clsEntries.push(entry);
                clsValue += entry.value;
              } else {
                clsEntries = [entry];
                clsValue = entry.value;
              }

              sendMetric({
                name: 'CLS',
                value: clsValue,
                id: entry.id
              });
            }
          }
        }).observe({ type: 'layout-shift', buffered: true });

        // Resource timing
        window.addEventListener('load', () => {
          setTimeout(() => {
            const resources = performance.getEntriesByType('resource');
            const metrics = {
              totalResources: resources.length,
              totalSize: resources.reduce((sum, r) => sum + (r.transferSize || 0), 0),
              totalDuration: resources.reduce((sum, r) => sum + r.duration, 0),
              slowestResource: resources.sort((a, b) => b.duration - a.duration)[0]
            };

            if (window.console && window.console.log) {
              console.log('Performance Metrics:', metrics);
            }
          }, 1000);
        });
      })();
    </script>
  `;

  $('body').append(perfScript);
}

async function processAllHTML() {
  const htmlFiles = [
    'visualization_hub.html',
    'medical_dashboard.html',
    'enhanced_3d_anatomy.html',
    'mobile_demo.html',
    'ar_viewer.html',
    'charts_library.html'
  ];

  const stats = [];

  for (const file of htmlFiles) {
    const inputPath = path.join(__dirname, '..', file);
    const outputPath = path.join(__dirname, '..', file.replace('.html', '.min.html'));

    try {
      // Check if file exists
      await fs.access(inputPath);
      const result = await optimizeHTML(inputPath, outputPath);
      stats.push(result);
      console.log(`✓ Optimized ${file} - Saved ${result.saved} bytes (${result.compressionRatio}% reduction)`);
    } catch (error) {
      console.log(`⚠ Skipping ${file} (file not found or error)`);
    }
  }

  // Print summary
  if (stats.length > 0) {
    const totalOriginal = stats.reduce((sum, s) => sum + s.originalSize, 0);
    const totalMinified = stats.reduce((sum, s) => sum + s.minifiedSize, 0);
    const totalSaved = totalOriginal - totalMinified;
    const avgCompression = ((1 - totalMinified / totalOriginal) * 100).toFixed(2);

    console.log('\n=== HTML Optimization Summary ===');
    console.log(`Total files processed: ${stats.length}`);
    console.log(`Original size: ${(totalOriginal / 1024).toFixed(2)} KB`);
    console.log(`Optimized size: ${(totalMinified / 1024).toFixed(2)} KB`);
    console.log(`Total saved: ${(totalSaved / 1024).toFixed(2)} KB`);
    console.log(`Average compression: ${avgCompression}%`);
  }
}

// Run if executed directly
if (require.main === module) {
  processAllHTML().catch(console.error);
}

module.exports = { optimizeHTML, processAllHTML };