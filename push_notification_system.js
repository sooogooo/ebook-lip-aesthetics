/**\n * Advanced Push Notification System\n * Intelligent user engagement tracking with ML-powered personalization\n * Supports rich notifications, actions, and analytics\n */\n\nclass AdvancedPushNotificationSystem {\n    constructor(options = {}) {\n        this.options = {\n            vapidPublicKey: options.vapidPublicKey || '',\n            serverEndpoint: options.serverEndpoint || '/api/notifications',\n            enableAnalytics: true,\n            enablePersonalization: true,\n            enableBadging: true,\n            enableRichNotifications: true,\n            maxNotificationsPerDay: 3,\n            quietHours: { start: 22, end: 8 }, // 22:00 to 08:00\n            enableLocationBasedNotifications: false,\n            enableBehaviorTracking: true,\n            retryAttempts: 3,\n            retryDelay: 5000,\n            ...options\n        };\n\n        this.state = {\n            isSubscribed: false,\n            subscription: null,\n            permission: 'default',\n            lastNotificationTime: 0,\n            notificationCount: 0,\n            engagementScore: 0,\n            userPreferences: new Map(),\n            analytics: {\n                sent: 0,\n                delivered: 0,\n                clicked: 0,\n                dismissed: 0,\n                optOuts: 0\n            }\n        };\n\n        this.userBehavior = {\n            sessionDuration: [],\n            interactionPatterns: new Map(),\n            preferredTimes: new Map(),\n            contentPreferences: new Map(),\n            engagementHistory: []\n        };\n\n        this.notification Queue = [];\n        this.personalizationModel = null;\n        this.analytics = null;\n        this.locationTracker = null;\n\n        this.init();\n    }\n\n    async init() {\n        try {\n            // Check browser support\n            if (!('serviceWorker' in navigator) || !('PushManager' in window)) {\n                console.warn('[PushNotifications] Browser does not support push notifications');\n                return;\n            }\n\n            // Load saved state\n            await this.loadState();\n\n            // Initialize analytics\n            if (this.options.enableAnalytics) {\n                await this.initializeAnalytics();\n            }\n\n            // Initialize personalization\n            if (this.options.enablePersonalization) {\n                await this.initializePersonalization();\n            }\n\n            // Initialize behavior tracking\n            if (this.options.enableBehaviorTracking) {\n                this.initializeBehaviorTracking();\n            }\n\n            // Check existing subscription\n            await this.checkExistingSubscription();\n\n            // Setup badge API if supported\n            if (this.options.enableBadging && 'setAppBadge' in navigator) {\n                this.initializeBadging();\n            }\n\n            // Setup periodic cleanup\n            this.setupPeriodicCleanup();\n\n            console.log('[PushNotifications] System initialized');\n        } catch (error) {\n            console.error('[PushNotifications] Initialization failed:', error);\n        }\n    }\n\n    async initializeAnalytics() {\n        this.analytics = {\n            track: (event, data) => this.trackEvent(event, data),\n            getMetrics: () => this.getAnalyticsMetrics(),\n            generateReport: () => this.generateAnalyticsReport(),\n            optimizeStrategy: () => this.optimizeNotificationStrategy()\n        };\n\n        // Load analytics from storage\n        const savedAnalytics = localStorage.getItem('pushNotification_analytics');\n        if (savedAnalytics) {\n            try {\n                this.state.analytics = { ...this.state.analytics, ...JSON.parse(savedAnalytics) };\n            } catch (error) {\n                console.warn('[PushNotifications] Failed to load analytics:', error);\n            }\n        }\n    }\n\n    async initializePersonalization() {\n        this.personalizationModel = {\n            predict: (context) => this.predictUserEngagement(context),\n            learn: (interaction) => this.learnFromInteraction(interaction),\n            getPersonalizedContent: (type) => this.getPersonalizedContent(type),\n            updatePreferences: (preferences) => this.updateUserPreferences(preferences)\n        };\n\n        // Load user behavior patterns\n        await this.loadUserBehavior();\n    }\n\n    initializeBehaviorTracking() {\n        // Track user sessions\n        this.trackSessionStart();\n\n        // Track page visibility changes\n        document.addEventListener('visibilitychange', () => {\n            if (document.hidden) {\n                this.trackSessionEnd();\n            } else {\n                this.trackSessionStart();\n            }\n        });\n\n        // Track user interactions\n        this.setupInteractionTracking();\n\n        // Track scroll behavior\n        this.setupScrollTracking();\n    }\n\n    initializeBadging() {\n        this.badgeAPI = {\n            set: (count) => navigator.setAppBadge(count),\n            clear: () => navigator.clearAppBadge(),\n            isSupported: () => 'setAppBadge' in navigator\n        };\n    }\n\n    /**\n     * Permission and Subscription Management\n     */\n    async requestPermission() {\n        try {\n            // Check if already granted\n            if (Notification.permission === 'granted') {\n                this.state.permission = 'granted';\n                return true;\n            }\n\n            // Check if permission was previously denied\n            if (Notification.permission === 'denied') {\n                console.warn('[PushNotifications] Permission was previously denied');\n                this.showPermissionEducation();\n                return false;\n            }\n\n            // Show educational prompt first\n            const userConsent = await this.showPermissionEducation();\n            if (!userConsent) {\n                return false;\n            }\n\n            // Request permission\n            const permission = await Notification.requestPermission();\n            this.state.permission = permission;\n\n            if (permission === 'granted') {\n                console.log('[PushNotifications] Permission granted');\n                this.trackEvent('permission_granted');\n                return true;\n            } else {\n                console.log('[PushNotifications] Permission denied');\n                this.trackEvent('permission_denied');\n                return false;\n            }\n        } catch (error) {\n            console.error('[PushNotifications] Permission request failed:', error);\n            return false;\n        }\n    }\n\n    async showPermissionEducation() {\n        return new Promise((resolve) => {\n            // Create educational modal\n            const modal = document.createElement('div');\n            modal.innerHTML = `\n                <div style=\"\n                    position: fixed;\n                    top: 0;\n                    left: 0;\n                    right: 0;\n                    bottom: 0;\n                    background: rgba(0, 0, 0, 0.8);\n                    display: flex;\n                    align-items: center;\n                    justify-content: center;\n                    z-index: 10000;\n                \">\n                    <div style=\"\n                        background: white;\n                        padding: 2rem;\n                        border-radius: 12px;\n                        max-width: 400px;\n                        margin: 1rem;\n                        text-align: center;\n                        color: #333;\n                    \">\n                        <div style=\"font-size: 3rem; margin-bottom: 1rem;\">ðŸ””</div>\n                        <h3 style=\"margin-bottom: 1rem; color: #d4af37;\">Stay Updated</h3>\n                        <p style=\"margin-bottom: 1.5rem; line-height: 1.6;\">Get notified about new aesthetic insights, case studies, and features. You can change this anytime in settings.</p>\n                        <div style=\"display: flex; gap: 1rem; justify-content: center;\">\n                            <button id=\"allow-notifications\" style=\"\n                                background: #d4af37;\n                                color: white;\n                                border: none;\n                                padding: 0.75rem 1.5rem;\n                                border-radius: 6px;\n                                cursor: pointer;\n                                font-weight: 500;\n                            \">Allow Notifications</button>\n                            <button id=\"not-now\" style=\"\n                                background: #ccc;\n                                color: #333;\n                                border: none;\n                                padding: 0.75rem 1.5rem;\n                                border-radius: 6px;\n                                cursor: pointer;\n                            \">Not Now</button>\n                        </div>\n                    </div>\n                </div>\n            `;\n\n            document.body.appendChild(modal);\n\n            const allowBtn = modal.querySelector('#allow-notifications');\n            const notNowBtn = modal.querySelector('#not-now');\n\n            allowBtn.addEventListener('click', () => {\n                document.body.removeChild(modal);\n                resolve(true);\n            });\n\n            notNowBtn.addEventListener('click', () => {\n                document.body.removeChild(modal);\n                resolve(false);\n            });\n\n            // Auto-dismiss after 30 seconds\n            setTimeout(() => {\n                if (modal.parentNode) {\n                    document.body.removeChild(modal);\n                    resolve(false);\n                }\n            }, 30000);\n        });\n    }\n\n    async subscribe() {\n        try {\n            // Request permission first\n            const hasPermission = await this.requestPermission();\n            if (!hasPermission) {\n                return false;\n            }\n\n            // Get service worker registration\n            const registration = await navigator.serviceWorker.ready;\n\n            // Check for existing subscription\n            let subscription = await registration.pushManager.getSubscription();\n\n            if (!subscription) {\n                // Create new subscription\n                subscription = await registration.pushManager.subscribe({\n                    userVisibleOnly: true,\n                    applicationServerKey: this.urlBase64ToUint8Array(this.options.vapidPublicKey)\n                });\n            }\n\n            this.state.subscription = subscription;\n            this.state.isSubscribed = true;\n\n            // Send subscription to server\n            await this.sendSubscriptionToServer(subscription);\n\n            // Save state\n            await this.saveState();\n\n            console.log('[PushNotifications] Successfully subscribed');\n            this.trackEvent('subscribed');\n\n            return true;\n        } catch (error) {\n            console.error('[PushNotifications] Subscription failed:', error);\n            this.trackEvent('subscription_failed', { error: error.message });\n            return false;\n        }\n    }\n\n    async unsubscribe() {\n        try {\n            if (this.state.subscription) {\n                await this.state.subscription.unsubscribe();\n                \n                // Notify server\n                await this.removeSubscriptionFromServer(this.state.subscription);\n                \n                this.state.subscription = null;\n                this.state.isSubscribed = false;\n\n                await this.saveState();\n                console.log('[PushNotifications] Successfully unsubscribed');\n                this.trackEvent('unsubscribed');\n            }\n        } catch (error) {\n            console.error('[PushNotifications] Unsubscribe failed:', error);\n        }\n    }\n\n    /**\n     * Intelligent Notification Scheduling\n     */\n    async scheduleNotification(notification, options = {}) {\n        const scheduleOptions = {\n            immediate: false,\n            optimal: true,\n            respectQuietHours: true,\n            personalizeContent: true,\n            ...options\n        };\n\n        try {\n            // Check if we should send notification\n            if (!this.shouldSendNotification(notification, scheduleOptions)) {\n                console.log('[PushNotifications] Notification blocked by rules');\n                return false;\n            }\n\n            // Personalize content if enabled\n            if (scheduleOptions.personalizeContent && this.personalizationModel) {\n                notification = await this.personalizeNotification(notification);\n            }\n\n            // Schedule based on user behavior\n            if (scheduleOptions.optimal && !scheduleOptions.immediate) {\n                const optimalTime = await this.calculateOptimalTime(notification);\n                if (optimalTime > Date.now()) {\n                    return this.scheduleForLater(notification, optimalTime);\n                }\n            }\n\n            // Send immediately\n            return await this.sendNotification(notification);\n        } catch (error) {\n            console.error('[PushNotifications] Scheduling failed:', error);\n            return false;\n        }\n    }\n\n    shouldSendNotification(notification, options) {\n        const now = new Date();\n        \n        // Check daily limit\n        if (this.state.notificationCount >= this.options.maxNotificationsPerDay) {\n            console.log('[PushNotifications] Daily limit reached');\n            return false;\n        }\n\n        // Check quiet hours\n        if (options.respectQuietHours && this.isQuietHours(now)) {\n            console.log('[PushNotifications] In quiet hours');\n            return false;\n        }\n\n        // Check minimum time between notifications (1 hour)\n        if (now.getTime() - this.state.lastNotificationTime < 3600000) {\n            console.log('[PushNotifications] Too soon since last notification');\n            return false;\n        }\n\n        // Check user engagement score\n        if (this.state.engagementScore < 0.3) {\n            console.log('[PushNotifications] Low engagement score');\n            return false;\n        }\n\n        return true;\n    }\n\n    isQuietHours(date) {\n        const hour = date.getHours();\n        const { start, end } = this.options.quietHours;\n        \n        if (start > end) {\n            // Spans midnight (e.g., 22:00 to 08:00)\n            return hour >= start || hour < end;\n        } else {\n            // Same day (e.g., 12:00 to 14:00)\n            return hour >= start && hour < end;\n        }\n    }\n\n    async calculateOptimalTime(notification) {\n        // Analyze user behavior patterns to find optimal time\n        const preferredTimes = this.userBehavior.preferredTimes;\n        const now = new Date();\n        \n        // Get user's most active hours\n        const mostActiveHour = this.getMostActiveHour();\n        \n        // Schedule for next occurrence of most active hour\n        const nextOptimalTime = new Date(now);\n        nextOptimalTime.setHours(mostActiveHour, 0, 0, 0);\n        \n        // If that time has passed today, schedule for tomorrow\n        if (nextOptimalTime <= now) {\n            nextOptimalTime.setDate(nextOptimalTime.getDate() + 1);\n        }\n        \n        // Avoid quiet hours\n        if (this.isQuietHours(nextOptimalTime)) {\n            nextOptimalTime.setHours(this.options.quietHours.end, 0, 0, 0);\n        }\n        \n        return nextOptimalTime.getTime();\n    }\n\n    getMostActiveHour() {\n        const hourActivity = new Map();\n        \n        // Analyze session data\n        this.userBehavior.sessionDuration.forEach(session => {\n            const hour = new Date(session.start).getHours();\n            hourActivity.set(hour, (hourActivity.get(hour) || 0) + session.duration);\n        });\n        \n        // Find hour with most activity\n        let maxActivity = 0;\n        let mostActiveHour = 10; // Default to 10 AM\n        \n        for (const [hour, activity] of hourActivity) {\n            if (activity > maxActivity) {\n                maxActivity = activity;\n                mostActiveHour = hour;\n            }\n        }\n        \n        return mostActiveHour;\n    }\n\n    async personalizeNotification(notification) {\n        if (!this.personalizationModel) return notification;\n\n        // Get user preferences\n        const preferences = this.getUserPreferences();\n        \n        // Customize title and body based on user behavior\n        const personalizedContent = await this.personalizationModel.getPersonalizedContent(notification.type);\n        \n        return {\n            ...notification,\n            title: personalizedContent.title || notification.title,\n            body: personalizedContent.body || notification.body,\n            data: {\n                ...notification.data,\n                personalized: true,\n                userSegment: this.getUserSegment()\n            }\n        };\n    }\n\n    /**\n     * Rich Notification Features\n     */\n    async sendNotification(notification) {\n        try {\n            // Enhanced notification with rich features\n            const enrichedNotification = {\n                title: notification.title,\n                body: notification.body,\n                icon: notification.icon || '/icons/icon-192x192.png',\n                badge: notification.badge || '/icons/badge-72x72.png',\n                image: notification.image,\n                data: {\n                    url: notification.url || '/',\n                    timestamp: Date.now(),\n                    id: this.generateNotificationId(),\n                    ...notification.data\n                },\n                actions: notification.actions || [\n                    {\n                        action: 'view',\n                        title: 'View',\n                        icon: '/icons/action-view.png'\n                    },\n                    {\n                        action: 'dismiss',\n                        title: 'Dismiss',\n                        icon: '/icons/action-dismiss.png'\n                    }\n                ],\n                requireInteraction: notification.requireInteraction || false,\n                silent: notification.silent || false,\n                tag: notification.tag || 'default',\n                renotify: notification.renotify || false,\n                vibrate: notification.vibrate || [200, 100, 200]\n            };\n\n            // Send to server for delivery\n            const response = await fetch(this.options.serverEndpoint, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({\n                    subscription: this.state.subscription,\n                    notification: enrichedNotification\n                })\n            });\n\n            if (response.ok) {\n                // Update state\n                this.state.lastNotificationTime = Date.now();\n                this.state.notificationCount++;\n                \n                // Track analytics\n                this.trackEvent('notification_sent', {\n                    type: notification.type,\n                    tag: notification.tag\n                });\n                \n                // Update badge if enabled\n                if (this.badgeAPI && this.badgeAPI.isSupported()) {\n                    this.badgeAPI.set(this.state.notificationCount);\n                }\n                \n                await this.saveState();\n                console.log('[PushNotifications] Notification sent successfully');\n                return true;\n            } else {\n                throw new Error(`Server responded with ${response.status}`);\n            }\n        } catch (error) {\n            console.error('[PushNotifications] Failed to send notification:', error);\n            this.trackEvent('notification_failed', { error: error.message });\n            return false;\n        }\n    }\n\n    /**\n     * User Behavior Analysis\n     */\n    trackSessionStart() {\n        this.currentSession = {\n            start: Date.now(),\n            interactions: 0,\n            scrollDepth: 0,\n            features: new Set()\n        };\n    }\n\n    trackSessionEnd() {\n        if (this.currentSession) {\n            const duration = Date.now() - this.currentSession.start;\n            \n            this.userBehavior.sessionDuration.push({\n                start: this.currentSession.start,\n                duration,\n                interactions: this.currentSession.interactions,\n                scrollDepth: this.currentSession.scrollDepth,\n                features: Array.from(this.currentSession.features)\n            });\n            \n            // Keep only recent sessions\n            if (this.userBehavior.sessionDuration.length > 100) {\n                this.userBehavior.sessionDuration.shift();\n            }\n            \n            this.updateEngagementScore();\n            this.saveUserBehavior();\n        }\n    }\n\n    setupInteractionTracking() {\n        ['click', 'touch', 'keydown'].forEach(eventType => {\n            document.addEventListener(eventType, () => {\n                if (this.currentSession) {\n                    this.currentSession.interactions++;\n                }\n            }, { passive: true });\n        });\n    }\n\n    setupScrollTracking() {\n        let maxScroll = 0;\n        \n        window.addEventListener('scroll', () => {\n            const scrollPercent = (window.scrollY / (document.body.scrollHeight - window.innerHeight)) * 100;\n            maxScroll = Math.max(maxScroll, scrollPercent);\n            \n            if (this.currentSession) {\n                this.currentSession.scrollDepth = maxScroll;\n            }\n        }, { passive: true });\n    }\n\n    updateEngagementScore() {\n        // Calculate engagement based on multiple factors\n        const sessions = this.userBehavior.sessionDuration;\n        if (sessions.length === 0) return;\n        \n        const recentSessions = sessions.slice(-10);\n        const avgDuration = recentSessions.reduce((sum, s) => sum + s.duration, 0) / recentSessions.length;\n        const avgInteractions = recentSessions.reduce((sum, s) => sum + s.interactions, 0) / recentSessions.length;\n        const avgScrollDepth = recentSessions.reduce((sum, s) => sum + s.scrollDepth, 0) / recentSessions.length;\n        \n        // Normalize and combine scores\n        const durationScore = Math.min(avgDuration / 300000, 1); // 5 minutes = 1.0\n        const interactionScore = Math.min(avgInteractions / 50, 1); // 50 interactions = 1.0\n        const scrollScore = avgScrollDepth / 100; // 100% scroll = 1.0\n        \n        this.state.engagementScore = (durationScore + interactionScore + scrollScore) / 3;\n    }\n\n    /**\n     * Analytics and Reporting\n     */\n    trackEvent(event, data = {}) {\n        if (!this.options.enableAnalytics) return;\n        \n        this.state.analytics[event] = (this.state.analytics[event] || 0) + 1;\n        \n        // Store detailed event data\n        const eventData = {\n            event,\n            timestamp: Date.now(),\n            data,\n            sessionId: this.currentSession?.start || Date.now()\n        };\n        \n        // Send to analytics service (implement as needed)\n        this.sendAnalyticsEvent(eventData);\n    }\n\n    async sendAnalyticsEvent(eventData) {\n        // Implement analytics service integration\n        console.log('[PushNotifications] Analytics event:', eventData);\n    }\n\n    getAnalyticsMetrics() {\n        const { sent, delivered, clicked, dismissed, optOuts } = this.state.analytics;\n        \n        return {\n            deliveryRate: sent > 0 ? (delivered / sent) * 100 : 0,\n            clickRate: delivered > 0 ? (clicked / delivered) * 100 : 0,\n            dismissalRate: delivered > 0 ? (dismissed / delivered) * 100 : 0,\n            optOutRate: sent > 0 ? (optOuts / sent) * 100 : 0,\n            engagementScore: this.state.engagementScore,\n            totalSent: sent,\n            totalClicked: clicked\n        };\n    }\n\n    /**\n     * Storage and State Management\n     */\n    async saveState() {\n        try {\n            const stateToSave = {\n                ...this.state,\n                subscription: this.state.subscription ? {\n                    endpoint: this.state.subscription.endpoint,\n                    keys: this.state.subscription.keys\n                } : null\n            };\n            \n            localStorage.setItem('pushNotification_state', JSON.stringify(stateToSave));\n        } catch (error) {\n            console.error('[PushNotifications] Failed to save state:', error);\n        }\n    }\n\n    async loadState() {\n        try {\n            const savedState = localStorage.getItem('pushNotification_state');\n            if (savedState) {\n                const parsedState = JSON.parse(savedState);\n                this.state = { ...this.state, ...parsedState };\n            }\n        } catch (error) {\n            console.error('[PushNotifications] Failed to load state:', error);\n        }\n    }\n\n    async saveUserBehavior() {\n        try {\n            localStorage.setItem('pushNotification_behavior', JSON.stringify(this.userBehavior));\n        } catch (error) {\n            console.error('[PushNotifications] Failed to save user behavior:', error);\n        }\n    }\n\n    async loadUserBehavior() {\n        try {\n            const savedBehavior = localStorage.getItem('pushNotification_behavior');\n            if (savedBehavior) {\n                this.userBehavior = { ...this.userBehavior, ...JSON.parse(savedBehavior) };\n            }\n        } catch (error) {\n            console.error('[PushNotifications] Failed to load user behavior:', error);\n        }\n    }\n\n    /**\n     * Utility Methods\n     */\n    urlBase64ToUint8Array(base64String) {\n        const padding = '='.repeat((4 - base64String.length % 4) % 4);\n        const base64 = (base64String + padding)\n            .replace(/-/g, '+')\n            .replace(/_/g, '/');\n        \n        const rawData = window.atob(base64);\n        const outputArray = new Uint8Array(rawData.length);\n        \n        for (let i = 0; i < rawData.length; ++i) {\n            outputArray[i] = rawData.charCodeAt(i);\n        }\n        \n        return outputArray;\n    }\n\n    generateNotificationId() {\n        return Date.now().toString(36) + Math.random().toString(36).substr(2);\n    }\n\n    getUserSegment() {\n        // Classify user based on engagement and behavior\n        if (this.state.engagementScore > 0.7) {\n            return 'highly_engaged';\n        } else if (this.state.engagementScore > 0.4) {\n            return 'moderately_engaged';\n        } else {\n            return 'low_engagement';\n        }\n    }\n\n    getUserPreferences() {\n        return Object.fromEntries(this.state.userPreferences);\n    }\n\n    /**\n     * Public API\n     */\n    async enableNotifications() {\n        return await this.subscribe();\n    }\n\n    async disableNotifications() {\n        return await this.unsubscribe();\n    }\n\n    isSubscribed() {\n        return this.state.isSubscribed;\n    }\n\n    getEngagementScore() {\n        return this.state.engagementScore;\n    }\n\n    setUserPreference(key, value) {\n        this.state.userPreferences.set(key, value);\n        this.saveState();\n    }\n\n    clearBadge() {\n        if (this.badgeAPI && this.badgeAPI.isSupported()) {\n            this.badgeAPI.clear();\n        }\n        this.state.notificationCount = 0;\n        this.saveState();\n    }\n\n    getStatus() {\n        return {\n            isSubscribed: this.state.isSubscribed,\n            permission: this.state.permission,\n            engagementScore: this.state.engagementScore,\n            analytics: this.getAnalyticsMetrics()\n        };\n    }\n\n    destroy() {\n        // Clean up event listeners and timers\n        if (this.currentSession) {\n            this.trackSessionEnd();\n        }\n        \n        // Save final state\n        this.saveState();\n        this.saveUserBehavior();\n    }\n}\n\n// Global instance\nwindow.AdvancedPushNotificationSystem = AdvancedPushNotificationSystem;\n\n// Auto-initialize if not in module environment\nif (typeof module === 'undefined') {\n    // Wait for DOM ready\n    if (document.readyState === 'loading') {\n        document.addEventListener('DOMContentLoaded', () => {\n            window.pushNotifications = new AdvancedPushNotificationSystem();\n        });\n    } else {\n        window.pushNotifications = new AdvancedPushNotificationSystem();\n    }\n}\n\nexport default AdvancedPushNotificationSystem;"